## **About this project** ðŸ“‚

This was my first OpenGL project, where I created a simple 3D bathroom sink scene. Through this project, I learned the basics of the OpenGL 
rendering pipeline, including how vertices, transformations, and shaders work together to produce graphics on screen. It gave me 
foundational experience in computer graphics and helped me understand how low-level rendering connects to building visual applications.

<p align="center">
<img width="400" height="684" alt="Screenshot 2025-08-14 at 11 21 46â€¯PM" src="https://github.com/user-attachments/assets/15df91a9-4a82-44ff-bc87-5d3558f32143" />
</p>


## **How do I approach designing software?** ðŸ’¡

Starting from the beginning is never easy, so I began by observing my daily surroundings. I chose to focus on just one object at first, 
and that object was the sink in my bathroom. I looked for other items in the bathroom that could be combined with geometric shapes. Then, 
I started sketching and gradually built the models in OpenGL. I experimented with basic shapes and added transformations for positioning 
and scaling. Finally, I refined the details with textures, materials, and lighting. At each step, I tested the output to ensure it matched 
my design before moving on. This project helped me develop the skill of thinking in terms of a graphics pipeline. I learned how to design 
objects not just visually, but also structurally, considering vertices, transformations, and textures. I believe that breaking down a 
complex visual idea into smaller components and building incrementally can be applied to many future software projects. This approach 
is similar to the Agile methodology commonly used in software development, where teams start by completing the basics first and then 
continue refining the product. I find this flexible approach beneficial because it allows for adjustments during development. 
If any errors arise, we can identify them early since we test the results after finishing each small feature or task. For instance 
in this project, I initially aimed to create a clean bathroom sink, but after experimenting with the lighting, I shifted 
to a creepier vibe for the bathroom instead.

## **How do I approach developing programs?** ðŸ’¾
For the 3D scene, I started by selecting the objects to model and considering how to represent them using basic geometric shapes, 
starting  with the bathroom sink. Initially, I used solid colors, which gave the scene a cartoon-like appearance. I then added 
textures, such as applying shiny metal to the faucet, a darker metal to the base, and the same finish for the drain inside the 
sink. Finally, I incorporated lighting to create a more realistic effect. After completing the first object, I moved on to the 
other items in the scene, following the same process.

I applied an incremental development strategy, building each object step by step while gradually adding complexity. I began 
with basic shapes, then proceeded to transformations, textures, materials, and lighting. I think iteration played a central 
role in my process; I implemented small parts each time, tested them, and refined them based on the results before moving 
forward. This approach allowed me to catch errors early and steadily improve the visual quality. Throughout the milestones, 
I learned to think ahead about structure, modularity, and the graphics pipeline. By combining incremental building with 
iterative testing, I was able to systematically refine the scene and complete the project efficiently.

## **How can computer science help me in reaching my goals?** ðŸš€

Creating a 3D scene using OpenGL taught me how to break complex problems into smaller, manageable pieces, plan solutions 
incrementally, and debug effectively. I think these experiences have strengthened my ability to tackle challenging software 
engineering tasks and develop high-quality maintainable code. This project also reinforced key concepts from my applied linear 
algebra classes, including vector spaces, inverse matrices, and using transformations to calculate reflections and manipulate 
objects in space, which gave me a deeper understanding of how mathematical theory applies to real-world programming.
Beyond the technical aspects, managing a large, complex codebase highlighted the critical importance of writing clean, 
well-organized code and thoroughly documenting functions.Overall, this experience has reinforced both my problem-solving 
and software development skills, which are directly applicable to my goals as a software engineer.
